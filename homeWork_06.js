// 1) Почитать про принципы программирования KISS, DRY, YAGNI + почитать про "Антипаттерны" Чистого кода

// Ответ: сделано.

// 2) Прочитать про способы хранения LocalStorage, SessionStorage и Cookie

// Ответ: сделано.

// 3) HTML / CSS - Базовая структура html документа, БЭМ методология

// Ответ:

// <!DOCTYPE html>
// <html lang="en">
// <head>
//     <meta charset="UTF-8">
//     <meta name="viewport" content="width=device-width, initial-scale=1.0">
//     <title>Подготовка к собесу</title>
//     <link rel="stylesheet" href="style.css">
// </head>
// <body>
//     <div class="one"></div>
//     <div class="two"></div>
//     <div class="one"></div>
//     <script type="module" src="scripts.js"></script>
// </body>
// </html>

// BEM (Block Element Modifier) - это методология именования классов CSS,
// разработанная компанией Яндекс. BEM предлагает структурировать код CSS
// и HTML, делая его более понятным, модульным и масштабируемым.

// Основные принципы BEM:

// 1. Блок (Block) - это независимый компонент,
// который может быть использован в любом месте страницы. 
// Класс блока начинается с названия блока (например, .block).
// Название блока характеризует смысл («что это?» — «меню»: menu, «кнопка»: button), 
// а не состояние («какой, как выглядит?» — «красный»: red, «большой»: big).

// 2. Элемент (Element) - это часть блока, 
// которая не имеет смысла вне контекста этого блока. Имя элемента разделяется двумя подчеркиваниями (например, .block__element).
// Название элемента характеризует смысл («что это?» — «пункт»: item, «текст»: text),
// а не состояние («какой, как выглядит?» — «красный»: red, «большой»: big).

// 3. Модификатор (Modifier) - это свойство блока или элемента, 
// которое изменяет его внешний вид или поведение. 
// Имя модификатора разделяется двумя тире (например, .block--modifier или .block__element--modifier).
// Название модификатора характеризует внешний вид («какой размер?», «какая тема?» и т. п. — «размер»: size_s, «тема»: theme_islands),
// состояние («чем отличается от прочих?» — «отключен»: disabled, «фокусированный»: focused)
// и поведение («как ведет себя?», «как взаимодействует с пользователем?» — «направление»: directions_left-top).


// 4) Почитать про паттерны функционального программирования + посмотреть примеры использования

// Ответ: сделано.

// 5) Способы позиционирования контента на странице

// Ответ: существуют 5 типов:

// static - этот тип присваивается всем элементам по умолчанию. Сами элементы находятся в основном потоке документа и перемещать их нельзя.

// relative - смещение не влияет на положение любых других элементов. 

// — элемент по-прежнему находиться в основном потоке.
// — смещается относительно себя (начального положения в документе) на основе значений top, right, bottom и left.
// — это значение создаёт новый контекст наложения, когда значение z-index не auto.

// sticky - смещение не влияет на положение любых других элементов.

// — элемент по-прежнему находиться в основном потоке, а затем смещается относительно его ближайшему предшественнику, имеющему «механизм прокрутки» (созданный при overflow равном hidden, scroll, auto или overlay), даже если тот не является ближайшим фактически прокручивающим предком, на основе значений top, right, bottom, и left.
// — это значение создаёт новый контекст наложения,
// Комбинирует в своей логике два типа позиционирования. Внутри видимой области браузера элемент ведет себя как fixed, при последующем скролле, прокручивается вместе с родителем, что напоминает поведение relative или absolute.

//  absolute

// - элемент удаляется из основного потока и он формирует новый поток.
// - смещается относительно (другого элемента у которого позиционирование не static, если такого нет, то относительно окна браузера) его конечная позиция определяется на основе значений top, right, bottom и left.
// - это значение создаёт новый контекст наложения, когда значение z-index не auto.
// - внешние отступы абсолютно спозиционированных блоков не схлопываются с отступами других блоков.

// fixed
// Он позиционируется относительно исходного содержащего блока, установленного viewport, за исключением случаев, когда один из его предков имеет свойство transform, perspective, или filter, установленное на что-то иное, кроме none (см. CSS Transforms Spec), и в этом случае этот предок ведёт себя как содержащий блок. (Обратите внимание, что существуют несогласованности браузера с perspective и filter, способствующими содержанию формирования блоков.) При печати fixed-элемент помещается в одно и то же место на каждой странице. 

// - элемент удаляется из основного потока, и он формирует новый поток.
// - смещается относительно окна браузера, игнорируя любое позиционирование родителя, его конечная позиция определяется на основе значений top, right, bottom и left.
// - это значение всегда создаёт новый контекст наложения.


// 6) Веса селекторов

// ответ: специфичность – способ с помощью,
// которого браузер определяет какие значение css свойств будут применены к элементу.
// На одном элементе может быть применено сразу несколько стилей,
// а вот какие именно стили будут отображены в браузере,
// зависит от специфичности, которое базируется на определении веса селектора.

// Вес селекторов:
// inline: 1000
// id: 100
// class/атрибут/псевдокласс: 10
// элемент и псевдоэлемент: 1
// Универсальный селектор (*):0.5
// Чтобы просчитать, необходимо просуммировать все входящие в него элементы. Это делается для написания более чистого кода без постоянного использования !important.
